#!/usr/bin/bash
#
# Build the given target.
#
# Author:   Alastair Hughes
# Contact:  < hobbitalastair at yandex dot com >

source "$(dirname "$0")/../../lib/libmain.sh"
source "$(dirname "$0")/../../lib/libtarget.sh"
source "$(dirname "$0")/../../lib/libpackage.sh"

path="${configdir}/src/${target}"
exists "${path}/PKGBUILD" || exit "$?"

# TODO: We should change BUILDDIR if there will not be enough space on the
#       given BUILDDIR, or something else should.
basedir="${BUILDDIR}/builder-${config[id]}/${target}"

extractsrctar() {
    # Find and extract the source tarball.
    local configdir="$1"
    local target="$2"
    local outdir="$3"       # Dir to extract to.

    # Find the source tarball.
    local srctar
    srctar="$(pkgdirsrctar "${configdir}" "${target}")" || \
        error 1 "Failed to find a source tarball for '${target}'!"

    # Extract the source tarball.
    pushd "${outdir}" > /dev/null
    bsdtar -xf "${configdir}/srctar/${srctar}" || \
        error 1 "Failed to extract '${configdir}/srctar/${srctar}' to $(pwd)!"
    # Move the source tarball to a more standard location.
    mv "$(printf "%s" "${srctar}" | rev | cut -d'-' -f3- | rev)" "pkg"
    popd > /dev/null
}

genconfigfiles() {
    # Generate the config files.
    local configdir="$1"
    local target="$2"
    local basedir="$3"

    # Generate the makepkg config file.
    genmakepkgconf "${configdir}" "${target}" >> "${basedir}/etc/makepkg.conf"
    printf "unset BUILDDIR" >> "${basedir}/etc/makepkg.conf"

    # Add the pacman config file.
    cat > "${basedir}/etc/pacman.conf" << EOF
EOF

    # Create the build script.
    if [ "${target%%/*}" == "packages" ]; then
        # TODO: Remove prefix-specific hack.
        makepkgargs="-d --nocheck"
    fi
    cat > "${basedir}/build.sh" << EOF
#!/usr/bin/bash
# Automatically generated build script - do not modify!
set -e
cd "pkg"
makepkg ${makepkgargs}
EOF
    chmod +x "${basedir}/build.sh"
}

buildpackage() {
    # Build the package.
    local basedir="$1"
    local prefix="$2"

    message info "Building the package..."

    if [ "${prefix}" == "native" ]; then
        # TODO: How much RAM is a good amount?
        # TODO: Is 'none' right?
        # TODO: Figure out when I can use KVM.
        fakeroot "${configdir}/qemu" \
            -kernel "${basedir}/boot/vmlinuz" \
            -append "console=ttyS0 init=/usr/bin/init
                root=r rootfstype=9p rootflags=trans=virtio panic=10" \
            -fsdev local,id=r,path="${basedir}",security_model=none,readonly \
            -device virtio-9p-pci,fsdev=r,mount_tag=r \
            -m 128 \
            -no-reboot -nographic || \
            error "$?" "Running qemu failed!"
        # TODO: Check the results.
    else
        # TODO: We appear to need this 'special' path for fakechroot chroots,
        #       as fakechroot is not 100% reliable...
        # TODO: Find a better fakechroot alternative?
        PATH="${basedir}/opt/${config[triplet]}/bin:${PATH}" \
            fakechroot chroot "${basedir}" /build.sh || \
            error "$?" "Running makepkg failed!"
    fi
}

checkprov() {
    # Fail if there are too many providers.
    dep="$1"
    shift
    if [ "$(printf "%s\n" "$@" | wc -l)" -gt 1 ]; then
        error 1 "Too many providers found for '${dep}': $@"
    elif [ -z "$1" ]; then
        error 1 "No providers found for '${dep}'!"
    fi
}

installdeps() {
    local configdir="$1"
    local target="$2"
    local basedir="$3"

    # Keep track of the dependencies corresponding to the various dirs.
    local tooldepends crossdepends nativedepends
    declare -a tooldepends
    declare -a crossdepends
    declare -a nativedepends

    # Declare the vars for the graph traversal.
    local visited stack
    declare -A visited
    declare -a stack

    # Initialise the stack and visited hash.
    # We cannot just put the target on the stack, as it has a different
    # dependency generation script, and should not end up in *depends.
    local deps
    deps="$("$(dirname "$0")/../../scripts/lsdeps.sh" \
        <(genmakepkgconf "${configdir}" "${target}") \
        "${configdir}/src/${target}/PKGBUILD")" || \
        error 1 "Failed to extract the deps from the PKGBUILD!"
    local dep prov
    while IFS=" " read dep prov; do
        checkprov "${dep}" "${prov}"
        visited["${prov}"]="${dep}"
        stack+=("${prov}")
    done < <(printf "%s\n" "${deps}" | \
        findpkgdeps "${configdir}" "${target%%/*}") || \
        error 3 "Failed to generate the package providers!"
    

    # Traverse the graph.
    while [ "${#stack}" -gt 0 ]; do
        # Visit each node.

        # Pop the item off the top of the stack.
        local current="${stack[-1]}"
        stack=(${stack[@]:0:$(expr "${#stack[@]}" - 1)})

        # Add the item to the appropriate list.
        case "${current%%/*}" in
            toolchain) tooldepends+=("${current}");;
            packages) crossdepends+=("${current}");;
            native) nativedepends+=("${current}");;
            host) # For host dependencies, we don't need to recurse.
                tooldepends+=("${current}")
                continue;;
            *) error 2 "Unknown provider prefix '${current%%/*}'!"
        esac

        # Process the dependencies.
        local dep prov
        while IFS=" " read dep prov; do

            message debug "${current} requires ${prov}"
            checkprov "${dep}" "${prov}"

            # If the provider is unvisited, add it to the stack and mark it
            # as visited.
            if [ -z "${visited["${prov}"]+is_set}" ]; then
                visited["${prov}"]="${dep}"
                stack+=("${prov}")
            fi
        done < <(sed "${configdir}/src/${current}/.SRCINFO" -n \
            -e '/^[ \t]*depends = /p' | \
            findpkgdeps "${configdir}" "${current%%/*}") || \
            error 3 "Failed to generate the package providers!"
    done

    # Install the dependencies.
    installtooldeps "${configdir}" "${target%%/*}" "${basedir}" \
        "${tooldepends[@]}"
    installcrossdeps "${configdir}" "${target%%/*}" "${basedir}" \
        "${crossdepends[@]}"
    installnativedeps "${configdir}" "${target%%/*}" "${basedir}" \
        "${nativedepends[@]}"
}

callpacman() {
    # Call pacman on the given sysroot.
    out="$@"
    message debug "Running pacman with args '--noconfirm --root $out'"
    fakechroot fakeroot pacman --noconfirm --root "$@" || \
        error 1 "Failed to run pacman on the root!"
}

mappkgs() {
    # Map the given dirs to actual packages.
    # TODO: Currently, we do not preserve the actual package names, so this is
    #       overly enthusiastic in the case of split packages.
    local configdir="$1"
    shift
    local targ pkg
    for targ in "$@"; do
        pkgdirpackages "${configdir}" "${targ}" | \
            while IFS= read pkg; do
                printf "%s/pkgs/%s\n" "${configdir}" "${pkg}"
            done || \
                error 2 "Failed to map '${targ}' to corresponding packages!"
    done
}

installtooldeps() {
    # Install the given list of host deps.
    # Fall back to the host packages if no matching packages are found.
    local configdir="$1"
    local prefix="$2"
    local basedir="$3"
    shift 3
    if [ "$#" -eq 0 ] && [ "${prefix}" != "packages" ]; then return; fi

    if [ "${prefix}" == "native" ]; then
        error 1 "Cannot install host deps to a native root!"
    fi

    message info "Installing toolchain packages to ${basedir}:"
    for i in "$@"; do message info "    $i"; done

    # Figure out which packages are host packages and which are tool deps.
    local pkg hostdeps toolchaindeps
    declare -a hostdeps
    declare -a toolchaindeps
    for pkg in "$@"; do
        if [ "${pkg%%/*}" == "host" ]; then
            hostdeps+=("${pkg##*/}")
        else
            toolchaindeps+=("${pkg}")
        fi
    done
    # We always install base-devel.
    # TODO: This takes a while, and is dependent on the local pacman.conf.
    #       What would be a better method?
    #       Can I cache this (in a tarball, perhaps?) and extract it before
    #       building anything? Would that be faster?
    hostdeps+=('base-devel')

    # Initialise the pacman sync databases.
    mkdir -p "${basedir}/var/lib/pacman" && \
        fakeroot cp -p -r /var/lib/pacman/sync "${basedir}/var/lib/pacman" || \
        error 1 "Failed to copy the host sync databases!"

    # Install base-devel.
    callpacman "${basedir}" --cachedir /var/cache/pacman/pkg -S ${hostdeps[@]}
    
    # Install the given packages.
    callpacman "${basedir}" --cachedir /var/cache/pacman/pkg -U \
        $(mappkgs "${configdir}" "$@")
}

installcrossdeps() {
    # Install the given list of cross compiled deps.
    local configdir="$1"
    local prefix="$2"
    local basedir="$3"
    shift 3
    if [ "$#" -eq 0 ]; then return; fi

    if [ "${prefix}" == "native" ]; then
        local root="${basedir}"
    else
        local root="${basedir}/sysroot/"
    fi

    message info "Installing cross compiled packages to ${root}:"
    for i in "${@}"; do message info "    $i"; done

    # Set up the root.
    if [ ! -d "${root}/var/lib/pacman" ]; then
        mkdir -p "${root}/var/lib/pacman"
    fi

    # Install the given packages.
    callpacman "${root}" --arch "${config[arch]}" \
        -U $(mappkgs "${configdir}" "${@}")
}

installnativedeps() {
    # Install the given list of native deps.
    local configdir="$1"
    local prefix="$2"
    local basedir="$3"
    shift 3
    if [ "$#" -eq 0 ]; then return; fi

    if [ "${prefix}" != "native" ]; then
        error 1 "Cannot install native deps to a non-native root!"
    fi

    message info "Installing native packages to ${basedir}:"
    for i in "$@"; do message info "    $i"; done

    # Set up the root.
    if [ ! -d "${basedir}/var/lib/pacman" ]; then
        mkdir -p "${basedir}/var/lib/pacman"
    fi

    # Install the given packages.
    callpacman "${basedir}" --arch "${config[arch]}" \
        -U $(mappkgs "${configdir}" "$@")
}


# Prepare the sysroot.
# Create the base dir.
if [ -e "${basedir}" ]; then
    error 1 "Build dir '${basedir}' already exists!"
fi
mkdir -p "${basedir}" || error 1 "Failed to create build dir '${basedir}'!"
# Populate the sysroot.
message info "Populating the sysroot..."
installdeps "${configdir}" "${target}" "${basedir}"
# Extract the source tarball.
message info "Unpacking the source tarball..."
extractsrctar "${configdir}" "${target}" "${basedir}"
# Generate the config files.
message info "Generating the config files..."
genconfigfiles "${configdir}" "${target}" "${basedir}"

# Build the package.
buildpackage "${basedir}" "${prefix}"

# Copy the built packages into the pkg dir.
cp "${basedir}"/pkg/*.pkg.tar.* "${configdir}/pkgs/" || \
    error 1 "No packages generated!"

# Clean up the build dir.
message info "Cleaning up..."
rm -rf "${basedir}"
exit 0
