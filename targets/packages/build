#!/usr/bin/bash
#
# Build the given target.
#
# Author:   Alastair Hughes
# Contact:  < hobbitalastair at yandex dot com >

source "$(dirname "$0")/../../libmain.sh"
source "$(dirname "$0")/../../libtarget.sh"
source "$(dirname "$0")/../../libpackage.sh"
read_config # Load the config.

# At this stage, we can assume that all of the dependencies have been built.
# We need to do quite a bit here...
path="${configdir}/src/${target}"
exists "${path}/PKGBUILD" || exit "$?"

# Create the clean chroot dir.
# TODO: Add locking...
cleanchroot="${TMPDIR:-/tmp}/builder-${config["id"]}/"
if [ ! -e "${cleanchroot}" ]; then
    mkdir "${cleanchroot}"
elif [ ! -d "${cleanchroot}" ]; then
    error 1 "Clean chroot dir '${cleanchroot}' already exists, but is not a dir!"
fi
# Create the basedir for this particular build.
basedir="${cleanchroot}/${target}"
if [ -e "${basedir}" ]; then
    error 1 "Build dir '${basedir}' already exists!"
fi
mkdir -p "${basedir}" || error 1 "Failed to create build dir '${basedir}'!"

# Populate the chroot.
chrootpacman() {
    fakechroot fakeroot pacman --cachedir /var/cache/pacman/pkg \
        --root "${basedir}" "$@" || \
        error 1 "Failed to run pacman on chroot!"
}
# TODO: Implement properly.
# TODO: This takes quite a while, and will redownload packages...
#       How to fix? Tar up a chroot somewhere? Keep a local cache?
#       This is also dependent on the local pacman.conf...
message info "Populating the chroot..."
mkdir -p "${basedir}/var/lib/pacman" && \
    chrootpacman --noconfirm -Syu base-devel

# Find the source tarball.
message info "Unpacking the source tarball..."
srctar="$(pkgdirsrctar "${configdir}" "${target}")" || \
    error 1 "Failed to find a source tarball for '${target}'!"
# Extract the source tar.
srctardir="${basedir}/$(echo "${srctar}" | rev | cut -d'-' -f3- | rev)"
pushd "${basedir}" > /dev/null
bsdtar -xf "${configdir}/srctar/${srctar}" || \
    error 1 "Failed to extract '${configdir}/srctar/${srctar}' to $(pwd)!"
popd > /dev/null

# Dependency resolution.
# TODO: Implement.
#       We have to deal with host dependencies, target dependencies,
#       and Arch (remote) dependencies.
# TODO: Dependencies *should* be evaluated using a graph.
# TODO: Make the distinction between build and install dependencies.
message info "Resolving remaining dependencies..."
deps="$(sed -n -e 's:  *: :g' -e '/# Depends:/p' < "${srctardir}/PKGBUILD" | \
    sed -e 's:# Depends\:::' | \
    tr ' ' '\n')" || error "$?" "Failed to read the dependency list!"
installpkg() {
    local pkgtype=""
    case "$1" in
        targets/*) for pkg in $(cat "${configdir}/src/$1"); do
                installpkg "${pkg}" || \
                    error "$?" "Failed to install pkg '${pkg}' with installpkg!"
            done; return 0;;
        packages/*) pkgtype="target";;
        toolchain/*) pkgtype="local";;
        *) error 1 "Unknown target '$1'";;
    esac
    local path="${configdir}/src/$1/PKGBUILD"
    for pkg in $(sed -n -e 's:  *: :g' -e '/# Depends:/p' < "${path}" | \
        sed -e 's:# Depends\:::' | \
        tr ' ' '\n'); do
        message info "Installing the dependencies of $1..."
        installpkg "${pkg}" || \
            error "$?" "Failed to install '${pkg}', a dependency of '$1'!"
    done
    message info "Installing $1..."
    # TODO: We do not recursively evaluate dependencies!
    local pkgnames="$(pkgdirpackages "${configdir}" "$1")" || \
        error "$?" "Failed to generate a list of pkgnames for '$1'!"
    local names files pkg
    for pkg in ${pkgnames}; do
        names+="$(echo "${pkg}" | rev | cut -d- -f4- | rev) "
        files+="${configdir}/pkgs/${pkg} "
    done
    if [ "${pkgtype}" == "local" ]; then
        if ! pacman --root "${basedir}" -Q ${names}; then
            yes 'y' | chrootpacman -U ${files}
        fi
    elif [ "${pkgtype}" == "target" ]; then
        sysroot="${basedir}/sysroot"
        if [ ! -d "${sysroot}/var/lib/pacman" ]; then
            mkdir -p "${sysroot}/var/lib/pacman"
        fi
        fakechroot fakeroot pacman -U --needed --noconfirm \
            --arch "${config[arch]}" \
            --root "${basedir}/sysroot" ${files} || \
            error 1 "Failed to install packages to sysroot: ${pkgnames}!"
    else
        error 1 "Unknown pkgtype '${pkgtype}'!"
    fi
}
for dep in ${deps}; do
    installpkg "${dep}" || error "Installing the dependencies failed!"
done
# TODO: Avoid special casing on prefix.
if [ "${prefix}" == "toolchain" ]; then
    # Find uninstalled dependencies, and install them.
    for dep in $(grep "${srctardir}/.SRCINFO" -e 'depends =' | \
        sed -e 's:.*= ::'); do
        if ! pacman --root "${basedir}" -Q "${dep}" > /dev/null; then
            chrootpacman --noconfirm -S "${dep}"
        fi
    done
fi

message info "Generating the config files..."
# TODO: We should extract some of these values from the local makepkg.conf,
#       if one exists (eg packager).
genmakepkgconf "${configdir}" "${target}" >> "${basedir}/etc/makepkg.conf"
# Add the pacman config file.
cat > "${basedir}/etc/pacman.conf" << EOF
EOF

# Create the build script.
if [ "${prefix}" == "packages" ]; then
    # TODO: Remove target-specific hack.
    makepkgargs="-d --nocheck"
fi
cat > "${basedir}/build.sh" << EOF
#!/usr/bin/bash
# Automatically generated build script - do not modify!
set -e
cd "${srctardir##*/}"
makepkg ${makepkgargs}
EOF
chmod +x "${basedir}/build.sh"

# Build the package.
message info "Building the package..."
fakechroot chroot "${basedir}" /build.sh || \
    error "$?" "Running makepkg failed!"

# Copy the built packages into the pkg dir.
# TODO: Locally built (toolchain) packages are architecture specific, and
#       should be dumped into a different directory?
cp "${srctardir}"/*.pkg.tar.* "${configdir}/pkgs/"

# Clean up the build dir.
message info "Cleaning up..."
rm -rf "${basedir}"
exit 0
