#!/usr/bin/bash
#
# Build the given target.
#
# Author:   Alastair Hughes
# Contact:  < hobbitalastair at yandex dot com >

source "$(dirname "$0")/../../libmain.sh"
source "$(dirname "$0")/../../libtarget.sh"
source "$(dirname "$0")/../../libpackage.sh"

# At this stage, we can assume that all of the dependencies have been built.
# We need to do quite a bit here...
path="${configdir}/src/${target}"
exists "${path}/PKGBUILD" || exit "$?"

# Set configdir to the realpath version.
configdir="$(realpath "${configdir}")" || \
    error 1 "Failed to get the realpath of the given config dir!"

# We set up a clean chroot.
# TODO: Actually use a clean chroot...
# TODO: What would be a clean way to do this?
#       We have some options - devtools, arch-install-scripts (pacstrap).
#       Either way, not particularily great.
# TODO: We should be able to configure this - where should it be stored?
#       In /tmp? Should chroots be persistent?
#       What are chroots, anyway?
# ====================
# A chroot is a directory structure with several packages unpackaged into it.
# By using a clean chroot, a reproducible build environment can be created,
# while avoiding pollution from other, unwanted packages.
#
# ====================
# On the host system, a clean chroot will have the base and base-devel upstream
# packages, preferably drawn from the local cache, and any additional
# dependencies of the package being built, drawn either from the other built
# packages, the local cache, or from online.
#
# For cross-compile chroots, a clean chroot will have the base upstream
# packages, any additional upstream packages that are required, and the
# appropriate toolchain packages.
# Inside of that, it will have another sysroot, which will have any additional
# dependencies of the package being built installed.
#
# ====================
# The basic scheme will be to install base (and base-devel, as needed), then
# to manually install any prebuilt dependencies, then to pull in the remaining
# dependencies from upstream using 'makepkg -s'.
#
# Note that makepkg -s will *not* work on an Takahe Linux box, so I might have
# to either fix that or install the packages manually.
# The clean chroot dir should be specific to this particular config dir, but
# I haven't implemented config files yet, so...
# We should also keep clean chroot dirs seperate for different packages?

# Create the clean chroot dir.
# TODO: Fix this so that it is different for different configs.
#       Also add locking...
cleanchroot="${TMPDIR:-/tmp}/builder/"
if [ ! -e "${cleanchroot}" ]; then
    mkdir "${cleanchroot}"
elif [ ! -d "${cleanchroot}" ]; then
    error 1 "Clean chroot dir '${cleanchroot}' already exists, but is not a dir!"
fi
# Create the basedir for this particular build.
basedir="${cleanchroot}/${target}"
if [ -e "${basedir}" ]; then
    error 1 "Build dir '${basedir}' already exists!"
fi
mkdir -p "${basedir}" || error 1 "Failed to create build dir '${basedir}'!"

# Populate the chroot.
chrootpacman() {
    fakechroot fakeroot pacman --cachedir /var/cache/pacman/pkg \
        --root "${basedir}" --noconfirm "$@" || \
        error 1 "Failed to run pacman on chroot!"
}
# TODO: Implement properly.
# TODO: This takes quite a while, and will redownload packages...
#       How to fix? Tar up a chroot somewhere? Keep a local cache?
#       This is also dependent on the local pacman.conf...
message info "Populating the chroot..."
mkdir -p "${basedir}/var/lib/pacman" && \
    chrootpacman -Syu base-devel

# Find the source tarball.
message info "Unpacking the source tarball..."
srctar="$(pkgdirsrctar "${configdir}" "${target}")" || \
    error 1 "Failed to find a source tarball for '${target}'!"
# Extract the source tar.
srctardir="${basedir}/$(echo "${srctar}" | rev | cut -d'-' -f3- | rev)"
pushd "${basedir}" > /dev/null
bsdtar -xf "${configdir}/srctar/${srctar}" || \
    error 1 "Failed to extract '${configdir}/srctar/${srctar}' to $(pwd)!"
popd > /dev/null

# Dependency resolution.
# TODO: Implement.
#       We have to deal with host dependencies, target dependencies,
#       and Arch (remote) dependencies.
# TODO: Dependencies *should* be recursively evaluated.
# TODO: Make the distinction between build and install dependencies.
message info "Resolving remaining dependencies..."
deps="$(sed -n -e 's:  *: :g' -e '/# Depends:/p' < "${srctardir}/PKGBUILD" | \
    sed -e 's:# Depends\:::' | \
    tr ' ' '\n')" || error "$?" "Failed to read the dependency list!"
installpkg() {
    local pkgtype=""
    case "$1" in
        targets/*) for pkg in $(cat "${configdir}/src/$1"); do
                installpkg "${pkg}" || \
                    error "$?" "Failed to install pkg '${pkg}' with installpkg!"
            done; return 0;;
        packages/*) pkgtype="target";;
        toolchain/*) pkgtype="local";;
        *) error 1 "Unknown target '$1'";;
    esac
    # TODO: Find the dependencies of the current target, and install them.
    local path="${configdir}/src/$1/PKGBUILD"
    for pkg in $(sed -n -e 's:  *: :g' -e '/# Depends:/p' < "${path}" | \
        sed -e 's:# Depends\:::' | \
        tr ' ' '\n'); do
        message info "Installing the dependencies of $1..."
        installpkg "${pkg}" || \
            error "$?" "Failed to install '${pkg}', a dependency of '$1'!"
    done
    message info "Installing $1..."
    # TODO: We do not recursively evaluate dependencies!
    local pkgnames="$(pkgdirpackages "${configdir}" "$1")" || \
        error "$?" "Failed to generate a list of pkgnames for '$1'!"
    if [ "${pkgtype}" == "local" ]; then
        chrootpacman -U "${configdir}/pkgs/${pkgnames}"
    elif [ "${pkgtype}" == "target" ]; then
        sysroot="${basedir}/opt/mips-linux-musl/sysroot"
        if [ ! -d "${sysroot}/var/lib/pacman" ]; then
            mkdir -p "${sysroot}/var/lib/pacman"
        fi
        # TODO: Don't use a hardcoded sysroot path...
        # TODO: This relies on pkgnames only returning a single package name.
        fakechroot fakeroot pacman -U --noconfirm --arch 'mips' \
            --root "${basedir}/opt/mips-linux-musl/sysroot" \
            "${configdir}/pkgs/${pkgnames}" || \
            error 1 "Failed to install packages to sysroot: ${pkgnames}!"
    else
        error 1 "Unknown pkgtype '${pkgtype}'!"
    fi
}
for dep in ${deps}; do
    installpkg "${dep}" || error "Installing the dependencies failed!"
done
# TODO: Avoid special casing on prefix.
if [ "${prefix}" == "toolchain" ]; then
    # Find uninstalled dependencies, and install them.
    for dep in $(grep "${srctardir}/.SRCINFO" -e 'depends =' | \
        sed -e 's:.*= ::'); do
        if ! pacman --root "${basedir}" -Q "${dep}" > /dev/null; then
            chrootpacman -S "${dep}"
        fi
    done
fi

message info "Generating the config files..."
# TODO: Some of these values should be custom?
# TODO: Implement this...
# Add the makepkg config file.
cat "${configdir}/src/config.sh" >> "${basedir}/etc/makepkg.conf" || \
    exit "$?"
if [ -f "${configdir}/src/${prefix}/makepkg.conf" ]; then
    cat "${configdir}/src/${prefix}/makepkg.conf" >> \
        "${basedir}/etc/makepkg.conf" || \
        exit "$?"
fi
# Add the pacman config file.
cat > "${basedir}/etc/pacman.conf" << EOF
EOF

# Mount the various directories.
# Note that this could be... fraught.
# If we then rm -rf /dev, for example, things will go badly...
message info "Mounting chroot directories..."
sudo mount -t proc proc "${basedir}/proc"
sudo mount --bind /dev "${basedir}/dev"
cleanup() {
    # Cleanup function.
    failed=""
    for fs in dev proc; do
        if [ -d "${basedir}/${fs}" ]; then
            sudo umount "${basedir}/${fs}" || \
                failed+="${fs} "
        fi
    done
    if [ -n "${failed}" ]; then
        error 1 "Failed to unmount a filesystem in the chroot (${failed})"
    fi
}
trap cleanup EXIT

# Create the build script.
cat > "${basedir}/build.sh" << EOF
#!/usr/bin/bash
# Automatically generated build script - do not modify!
set -e
cd "${srctardir##*/}"
makepkg
EOF
chmod +x "${basedir}/build.sh"

# Build the package.
message info "Building the package..."
fakechroot chroot "${basedir}" /build.sh || \
    error "$?" "Running makepkg failed!"

# Copy the built packages into the pkg dir.
# TODO: Locally built (toolchain) packages are architecture specific, and
#       should be dumped into a different directory?
cp "${srctardir}"/*.pkg.tar.* "${configdir}/pkgs/"

# Clean up the build dir.
message info "Cleaning up..."
cleanup
rm -rf "${basedir}"
