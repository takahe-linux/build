#!/usr/bin/bash
#
# Build the given target.
#
# Author:   Alastair Hughes
# Contact:  < hobbitalastair at yandex dot com >

source "$(dirname "$0")/../../lib/libmain.sh"
source "$(dirname "$0")/../../lib/libtarget.sh"
source "$(dirname "$0")/../../lib/libpackage.sh"

path="${configdir}/src/${target}"
exists "${path}/PKGBUILD" || exit "$?"

# TODO: We should change BUILDDIR if there will not be enough space on the
#       given BUILDDIR, or something else should.
basedir="${BUILDDIR}/builder-${config[id]}/${target}"

mkbuilddir() {
    # Create the basedir for this particular build.
    if [ -e "${basedir}" ]; then
        error 1 "Build dir '${basedir}' already exists!"
    fi
    mkdir -p "${basedir}" || error 1 "Failed to create build dir '${basedir}'!"
}

chrootpacman() {
    fakechroot fakeroot pacman --cachedir /var/cache/pacman/pkg \
        --root "${basedir}" "$@" || \
        error 1 "Failed to run pacman on the chroot!"
}

populatechroot() {
    # Populate the chroot.
    # TODO: This takes a while, and is dependent on the local pacman.conf.
    #       What would be a better method?
    #       Can I cache this (in a tarball, perhaps?) and extract it before
    #       building anything?
    #       What happens when this is updated?
    #       Should I rebuild everything, or leave them alone?
    message info "Populating the chroot..."
    mkdir -p "${basedir}/var/lib/pacman" && \
        fakeroot cp -p -r /var/lib/pacman/sync "${basedir}/var/lib/pacman" && \
        chrootpacman --noconfirm -S base-devel
}

genconfigfiles() {
    # Generate the config files.

    message info "Generating the config files..."

    # Generate the makepkg config file.
    genmakepkgconf "${configdir}" "${target}" >> "${basedir}/etc/makepkg.conf"

    # Add the pacman config file.
    cat > "${basedir}/etc/pacman.conf" << EOF
EOF

    # Create the build script.
    if [ "${prefix}" == "packages" ]; then
        # TODO: Remove prefix-specific hack.
        makepkgargs="-d --nocheck"
    fi
    cat > "${basedir}/build.sh" << EOF
#!/usr/bin/bash
# Automatically generated build script - do not modify!
set -e
cd "${srctardir##*/}"
makepkg ${makepkgargs}
EOF
    chmod +x "${basedir}/build.sh"
}

buildpackage() {
    # Build the package.
    message info "Building the package..."
    # TODO: We appear to need this 'special' path for fakechroot chroots, as
    #       fakechroot is not 100% reliable...
    # TODO: Find a better fakechroot alternative?
    PATH="${basedir}/opt/${config[triplet]}/bin:${PATH}" \
        fakechroot chroot "${basedir}" /build.sh || \
        error "$?" "Running makepkg failed!"
}

# Prepare the chroot.
mkbuilddir
populatechroot
# Extract the source tarball.
message info "Unpacking the source tarball..."
srctardir="$(extractsrctar "${configdir}" "${target}" "${basedir}")" || \
    error 1 "Failed to extract the source tarball!"

# Dependency resolution.
# TODO: Dependencies *should* be evaluated using a graph.
message info "Resolving remaining dependencies..."
deps="$("$(dirname "$0")/../../scripts/lsdeps.sh" \
    <(genmakepkgconf "${configdir}" "${target}") "${path}/PKGBUILD")" || \
    error 1 "Failed to extract the deps from the PKGBUILD!"
hostinstall() {
    # Install the given package to the host chroot.
    local pkg="$1"

    if pacman -Q --root "${basedir}" "${pkg}" > /dev/null 2>&1; then
        # Package is already installed; bail.
        return
    fi

    message info "Installing host package ${pkg}..."

    local providers="$(findpkgdir "${configdir}" "${pkg}" "toolchain")" || \
        error 1 "Failed to generate providers for '${pkg}'!"
    local provcount="$(printf "%s\n" "${providers}" | wc -l)"
    if [ "${provcount}" -gt 1 ]; then
        error 2 "Ambiguous package name: '${pkg}' (got '${providers}')"
    elif [ "${provcount}" -eq 1 ] && [ -n "${providers}" ]; then
        # Install the given package locally.
        # TODO: This method is convoluted and installs too many packages...
        # TODO: Reduce duplication here.
        local pkgfiles
        pkgfiles="$(pkgdirpackages "${configdir}" "${providers}")" || \
            error 3 \
            "Failed to find the packages for package dir '${providers}'!"
        while IFS= read line; do
            local pkgfile="${configdir}/pkgs/${line}"
            # Install the dependencies of the package.
            pkgdeps="$(bsdtar -O -xf "${pkgfile}" .PKGINFO | \
                sed -n -e '/^depend = /p' | cut -d '=' -f2- | 
                sed -e 's:[ \t]::g')" || \
                error 4 \
                    "Failed to generate a list of dependencies for '${pkgfile}'!"
            printf "Deps: '${pkgdeps}' (pkgfile: ${pkgfile})\n"
            while IFS= read dep; do
                [ -n "${dep}" ] && hostinstall "${dep}"
            done < <(printf "%s\n" "${pkgdeps}")

            # Install the given package.
            printf "Installing host package file '${pkgfile}'\n"
            chrootpacman --noconfirm -U "${pkgfile}" || \
                error 1 "Failed to install packages to sysroot: ${pkgfile}!"
        done < <(printf "%s\n" "${pkgfiles}")
    else
        # Install the given package which is not provided locally.
        chrootpacman --noconfirm --needed -S "${pkg}"
    fi
}
crossinstall() {
    # Install the given package to the sysroot.
    local pkg="$1"

    # Set up the sysroot.
    local sysroot="${basedir}/sysroot"
    if [ ! -d "${sysroot}/var/lib/pacman" ]; then
        mkdir -p "${sysroot}/var/lib/pacman"
    fi

    # Bail if the package is already installed.
    if pacman -Q --root "${sysroot}" "${pkg}" > /dev/null 2>&1; then
        return
    fi

    message info "Installing cross package ${dep}..."

    # Find the corresponding package file.
    local providers="$(findpkgdir "${configdir}" "${pkg}" "packages")" || \
        error 1 "Failed to generate providers for '${pkg}'!"
    local provcount="$(printf "%s\n" "${providers}" | wc -l)"
    if [ "${provcount}" -ne 1 ]; then
        error 2 "Ambiguous package name: '${pkg}' (got '${providers}')"
    fi
    local line pkgfiles pkgdeps dep
    # TODO: This installs too many packages.
    pkgfiles="$(pkgdirpackages "${configdir}" "${providers}")" || \
        error 3 "Failed to find the packages for package dir '${providers}'!"

    while IFS= read line; do
        local pkgfile="${configdir}/pkgs/${line}"
        # Install the dependencies of the package.
        pkgdeps="$(bsdtar -O -xf "${pkgfile}" .PKGINFO | \
            sed -n -e '/depend = /p' | cut -d '=' -f2- | \
            sed -e 's:[ \t]::g')" || \
            error 4 \
                "Failed to generate a list of dependencies for '${pkgfile}'!"
        while IFS= read dep; do
            [ -n "${dep}" ] && crossinstall "${dep}"
        done < <(printf "%s\n" "${pkgdeps}")

        # Install the given package.
        fakechroot fakeroot pacman -U --noconfirm --arch "${config[arch]}" \
            --root "${sysroot}" "${pkgfile}" || \
            error 1 "Failed to install packages to sysroot: ${pkgfile}!"
    done < <(printf "%s\n" "${pkgfiles}")
}
# Generate the deps and evaluate them.
while IFS="= $(printf '\t\n')" read deptype dep; do
    if [ -z "${dep}" ]; then
        continue
    fi
    if [ "${deptype}" == "hostdepends" ]; then
        # Install a package to the host chroot.
        hostinstall "${dep}"
    elif [ "${prefix}" == "toolchain" ] && \
        [ "${deptype}" != "targetdepends" ]; then
        # Install a package to the host chroot.
        hostinstall "${dep}"
    else
        # Install a package to the sysroot.
        crossinstall "${dep}"
    fi
done < <(printf "%s\n" "${deps}")

genconfigfiles

# Build the package.
buildpackage

# Copy the built packages into the pkg dir.
# TODO: Locally built (toolchain) packages are architecture specific, and
#       should be dumped into a different directory?
cp "${srctardir}"/*.pkg.tar.* "${configdir}/pkgs/"

# Clean up the build dir.
message info "Cleaning up..."
rm -rf "${basedir}"
exit 0
